## 冒泡排序
* 冒泡排序原理
```
1. 从下标为 0 到 n-1 的元素.即（0，n-1）,依次比较相邻两个元素，把最大（或最小）的数移动到最右边位置，即下标为 n-1处
2. 再从下标为 0 到 n-2 的元素.即（0，n-2），依次比较相邻两个元素，把最大（或最小）的数移动到 最右边-1 位置，即下标
   为 n-2 处
3. 一直重复 n躺 即可达到排序效果
```
* Go的冒泡排序
```
func bubblesort(values []int) []int {
    ii := len(values)
    for i := 0; i < ii; i++ {
        for j := 0; j < ii - i - 1; j++ {
           if values[j] < values[j + 1] {
                values[j], values[j + 1] = values[j + 1], values[j]
           }
        }
    }
    return values
}
```
* 冒泡排序的时间复杂度
```
其复杂度为O(N^2)
```
* 冒泡排序的改进
```
给定一个整数序列{6,1,2,3,4},每完成一次外层循环的结果为：
6,1,2,3,4
1,2,3,4,6 此时 i = 0；
1,2,3,4,6 此时 i = 1；
1,2,3,4,6 此时 i = 2；
1,2,3,4,6 此时 i = 3；
我们发现第一次外层循环之后就排序成功了，但是还是会继续循环下去，造成了不必要的时间复杂度
```
* Go改进后的冒泡排序
```
func bubblesort(values []int) []int {
    var flag bool
    ii := len(values)
    for i := 0; i < ii; i++ {
        flag = true
        for j := 0; j < ii - i -1; j++ {
            if  values[j] < values[j + 1] {
                values[j], values[j + 1] = values[j + 1], values[j]
                flag = false
            }
        }
        if flag == true {
            break
        }
    }
    return values
}
```
* 改进后的冒泡排序的时间复杂度
```
最好的情况是O(N)
```
## 快速排序法
* 原理分析
```
假设我们现在对“6  1  2 7  9  3  4  5 10  8”这个10个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，
就是一个用来,参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数
大的数放在6的右边，比基准数小的数放在6的左边，类似下面这种排列：
```
3  1  2 5  4  **6**  9 7  10  8
```
在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k。现在就需要寻找这个k，并且以第k位为分
界点，左边的数都小于等于6，右边的数都大于等于6
方法其实很简单：分别从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6
的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始
的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。
```
![](https://github.com/Yangliangfeng/GO/raw/master/images/1.jpg)

