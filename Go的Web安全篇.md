## CSRF攻击
### 什么是CSRF

CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF

那么CSRF到底能够干嘛呢？你可以这样简单的理解：攻击者可以盗用你的登陆信息，以你的身份模拟发送各种请求。

所以遇到CSRF攻击时，将对终端用户的数据和操作指令构成严重的威胁；当受攻击的终端用户具有管理员帐户的时候，CSRF攻击将危及整个Web应用程序。

### CSRF的原理

![](https://github.com/Yangliangfeng/GO/raw/master/images/11.jpg)

从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤 ：
  * 1.登录受信任网站A，并在本地生成Cookie 
  * 2.在不退出A的情况下，访问危险网站B

### 预防CSRF

服务端的预防CSRF攻击的方式方法有多种，但思想上都是差不多的，主要从以下2个方面入手：
  * 1.正确使用GET,POST和Cookie
  * 2.在非GET请求中增加伪随机数

因此，一般都是按照如下方式设计应用：
  * 1.GET常用在查看，列举，展示等不需要改变资源属性的时候
  * 2.POST常用在下达订单，改变一个资源的属性或者做其他一些事情

这样处理后，因为我们限定了修改只能使用POST，当GET方式请求时就拒绝响应，所以上面图示中GET方式的CSRF攻击就可以防止了，但这样就能全部解决问题了吗？当然不是，因为POST也是可以模拟的。

因此我们需要实施第二步，在非GET方式的请求中增加随机数，这个大概有三种方式来进行：
  * 1.为每个用户生成一个唯一的cookie token，所有表单都包含同一个伪随机值，这种方案最简单，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败，但是由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，所以这个方案必须要在没有XSS的情况下才安全。
  * 2.每个请求使用验证码，这个方案是完美的，因为要多次输入验证码，所以用户友好性很差，所以不适合实际运用
  * 3.不同的表单包含一个不同的伪随机值(就是每个表单随机生成token，然后在表单提交的时候，比对表单提交过来的token)，这种方式是比较安全且使用比较频繁的。

## XSS攻击
### 什么是XSS

XSS攻击：跨站脚本攻击(Cross-Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。XSS是一种常见的web安全漏洞，它允许攻击者将恶意代码植入到提供给其它用户使用的页面中。XSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。

XSS通常可以分为两大类：一类是存储型XSS，主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等。应用程序从数据库中查询数据，在页面中显示出来，攻击者在相关页面输入恶意的脚本数据后，用户浏览此类页面时就可能受到攻击。这个流程简单可以描述为:恶意用户的Html输入Web程序->进入数据库->Web程序->用户浏览器。另一类是反射型XSS，主要做法是将脚本代码加入URL地址的请求参数里，请求参数进入程序后在页面直接输出，用户点击类似的恶意链接就可能受到攻击。

XSS目前主要的手段和目的如下：
  * 盗用cookie，获取敏感信息
  * 利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作
  * 利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击者）用户的身份执行一些管理动作，或执行一些如:发微博、加好友、发私信等常规操作，     前段时间新浪微博就遭遇过一次XSS。
  * 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动
  * 在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果
### 产生XSS的原因

Web应用未对用户提交请求的数据做充分的检查过滤，允许用户在提交的数据中掺入HTML代码(最主要的是“>”、“<”)，并将未经转义的恶意代码输出到第三方用户的浏览器解释执行，是导致XSS漏洞的产生原因。
### 预防XSS

答案很简单，坚决不要相信用户的任何输入，并过滤掉输入中的所有特殊字符。这样就能消灭绝大部分的XSS攻击。

目前防御XSS主要有如下几种方式：
  * 过滤特殊字符
  
    避免XSS的方法之一主要是将用户所提供的内容进行过滤，Go语言提供了HTML的过滤函数：
    
    text/template包下面的HTMLEscapeString、JSEscapeString等函数
  * 使用HTTP头指定类型
    ```
    w.Header().Set("Content-Type","text/javascript")
    
    这样就可以让浏览器解析javascript代码，而不会是html输出。
    ```
